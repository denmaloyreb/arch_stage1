# 3.8 Практическая работа

## Задача

>**Цели домашнего задания**

>Повторить материал и более осознанно понять сходства и различия разных подходов. 
>По-новому взглянуть на динамику характеристик архитектурных стилей при помощи сводной таблицы. В дальнейшем (в том числе и в следующих домашних заданиях) такая таблица поможет легче выбрать архитектурный стиль. 

>**Что нужно сделать**

>Анализ и систематизация полученной информации — важный навык архитектора. Проведите сравнительный анализ архитектурных стилей. На основе знакомства на уроке с основными стилями распределённой архитектуры, а также на основе своего опыта работы с монолитным приложением оцените следующие стили: 

>* Монолит.
>* Service-Oriented.
>* Service-Based. 
>* Space-Based. 
>* Event-Driven.
>* Microservices. 

>Для оценки воспользуйтесь списком характеристик. Названия даны на английском, чтобы легче было искать определения. К тому >же не все термины можно однозначно перевести на русский язык. Выберите 5–7 характеристик и оцените каждый стиль по >пятибалльной шкале: 

>Agility. 
>Abstraction level. 
>Configurability. 
>Cost. 
>Deployability. 
>Domain partitioning.
>Elasticity.
>Evolvability.
>Fault Tolerance. 
>Integration. 
>Interoperability. 
>Performance. 
>Scalability.
>Simplicity.
>Testability.

>В результате должна получиться сводная таблица со стилями и характеристиками: 

>названия стилей в шапке таблицы по горизонтали; 
>характеристики по вертикали; 
>на пересечении оценка, насколько полно стиль позволяет реализовать характеристику. 

>**Опционально:**

>Кратко опишите, почему вы решили выставить такие оценки каждому стилю. 
>Добавьте в таблицу стили модульный монолит и microkernel с самостоятельным поиском информации. Эти стили могут считаться переходными формами от монолита к распределённым стилям. 

## Решение

|Стили/характеристики|Монолит|Service-Oriented|Service-Based|Space-Based|Event-Driven|Microservices|
|--------|-------|---------|-----------|---------|--------|--------|
|**Agility**</br>Гибкость|**2**</br>С ростом приложения оно становится менее гибким|**5**</br>Гибкость (в т.ч. из-за переиспользования) — одна из "основных основ" SOA|**3**</br>Команда, ответственная за изменение схемы БД (если она одна, а если нет — нужно выбирать между скоростью и актуальностью данных), может стать "бутылочным горлышком"|**5**</br>Гибкость на высоком уровне. Это одна из проблем, на решение которых опирались при разработке подхода|**4**</br>Довольно гибкая система|**5**</br>Гибкость на высоком уровне
|**Abstraction level**</br>Уровень абстракции|**1**</br>Сложно разделить бизнес-логику и код|**3**</br>Внимание разделению бизнес-логики и кода|**3**</br>Каждый сервис отвечает за одну достаточно большую бизнес-функцию, но в то же время можно "залезть" в зону ответственности другого сервиса|**4**</br>Возможна ситуация, когда бизнес-логика проникает в БД|**4**</br>Слабая связанность сервисов|**5**</br>Здесь все почти идеально: микросервисы самодостаточны и  не влияют (почти) друг на друга
|**Cost**</br>Цена покупки и владения|**4**</br>Для небольших приложений все ОК. Но с их ростом внедрение фич может занимать много времени и сказываться на выгоде|**2**</br>Покупка ESB — удовольствие не из дешевых|**3**</br>Цену можно "регулировать" проектируя каждый сервис в своей архитектуре|**2**</br>Большая зависимость от используемых технологий, например от типа кэша: чем лучше синхронизация данных, тем выше накладные расходы. Спец. ПО стоит немало|**2**</br>Недешевое удовольствие|**1**</br>Требуется много команд для работы над микросервисами. А их работу еще нужно координировать, что может увеличивать штат. Плюс своя БД для каждого микросервиса и т.д.
|**Deployability**</br>Развертываемость|**5**</br>Один сервис легко развернуть, чем несколько|**3**</br>Много развертываемых модулей, которые могут зависеть друг от друга, что усложняет процессы автоматизации развертывания|**5**</br>Сервисы независимы друг от друга и их легче развертывать|**4**</br>За счет довольно самостоятельных Process Units|**4**</br>Компоненты легко развертываются, легко добавлять новые экземпляры|**5**</br>Сервисы развертываются независимо друг от друга
|**Fault Tolerance**</br>Отказоустойчивость|**1**</br>Все в одном репо/процессе. Проблема в одном компоненте может обрушить все приложение|**2**</br>ESB и ее команда — "узкое место" системы|**4**</br>Сервисы не зависят друг от друга, но при общей БД могут быть взаимные блокировки. Нужно хорошо поработать с представлениями|**4**</br>Подход хорошо приспособлен к решению проблем, связанных с большой нагрузкой, но в то же время отказоустойчивость может зависеть от механизма кэширования|**3**</br>Высокая надежность, в т.ч. за счет возможности создания временных окон, но полная отказоустойчивость не гарантируется|**4**</br>Каждая интеграция — мина замедленного действия. При определенных обстоятельствах можно ждать каскадного отключения сервисов
|**Interoperability**</br>Взаимодействие между компонентами|**2**</br>Компоненты тесно связаны между собой, плюс еще нужно следить за их совместимостью|**3**</br>SOA позволяет организовать эффективное взаимодействие между разными компонентами. Но с ростом количества логики, шина может стать "бутылочным горлышком" + синхронизация инстансов БД|**4**</br>Синхронизация с ростом системы становится сложнее и дороже|**3**</br>Такая оценка из-за коллизий репликации, а также из-за низкой согласованности данных|**3**</br>Серьезные усилия на обеспечение гранулярности данных|**5**</br>Обмен данными между микросервисами не требует сложной логики
|**Scalability**</br>|**2**</br>Горизонтальное масштабирование. Но до поры до времени, пока пприложение не слишком большое|**3**</br>Масштабировать может быть сложно, в т.ч. из-за переиспользования, когда нужна куча согласоаний|**4**</br>Независимые сервисы = хорошая масштабируемость, но все может тормозить общая БД|**5**</br>Отличный вариант для приложений с непредсказуемой пользовательской нагрузкой|**5**</br>Хорошо масштабируемые и гибкие сервисы|**5**</br>Отличная масштабируемость
|**Testability**</br>Тестируемость|**4**</br>Внесение почти любого изменения требует полного регрессивного тестирования|**1**</br>Тестирование затруднено: компоненты, как правило являются "незавершенными" частями общего продукта и по-отдельности тестировать их сложно|**4**</br>Тестируемость на достаточно высоком уровне|**3**</br>Каждый Process Init достаточно самостоятелен, что сказывается на тестируемости, но тестирование всей системы затруднено|**4**</br>За счет небольшой связанности компонентов, меньшей вариативности данных для каждого (в зависимости от шаблона)|**3**</br>Требуется реализация юнит-тестирования, функциональные тесты, интеграционные, а потом, если все ОК - еще и ручками
